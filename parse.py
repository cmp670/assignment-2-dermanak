
import sys
import numpy as np


def wordsCount(s, terms):
    # to count the number of words in the given sentences
    if ' ' in s:
        splits = s.split(' ')
        return len(splits)
    else:
        return len(s)


class Part:
    def __init__(self, token, firstchild=None, secondchild=None, words=None):
        # Constructing method
        self.token = token
        self.firstchild = firstchild
        self.secondchild = secondchild
        self.words = words


def updateFirstWord(token, tokenPos, rules, variables, table):
    # the first step of the algorithm; that is, the transformation of Variables to terminalSymbol

    for rule in rules:
        if token == rule[1]:
            table[0][tokenPos].append(Part(token=rule[0], words=rule[1]))

def getWords(words):
    # to get the words from the given dictionary
    return words


def getChild2(secondchild):
    # to take the second child
    return secondchild


def getChild1(firstchild):
    # to take the first child
    return firstchild


def loopOver(firstchild, firstparentLength, l, left, p, right1, right2, s, secondchild, table):
    for i in range(firstparentLength):
        if right1 == getToken(table[p][s][i].token):
            firstchild = table[p][s][i]
    secondparentLength = len(table[l - p - 1][s + p + 1])
    parent2Symbs = []
    for i in range(secondparentLength):
        if right2 == getToken(table[l - p - 1][s + p + 1][i].token):
            secondchild = table[l - p - 1][s + p + 1][i]
    if firstchild != None and secondchild != None:
        table[l][s].append(Part(token=left, firstchild=firstchild, secondchild=secondchild))

def isRight(l, left, p, right, s, table, words):
    if right not in words:
        firstchild = None
        secondchild = None
        right1 = right.split(' ')[0]
        right2 = right.split(' ')[1]

        firstparentLength = len(table[p][s])
        parent1Symbs = []
        loopOver(firstchild, firstparentLength, l, left, p, right1, right2, s, secondchild, table)


def getToken(token):
    # Method to get the symbol which I called it as token
    return token


def updateWords(rules, variables, words, table, l, s, p):
    # all other steps of the algorithm; that is, the transformation of Variables to Variables1 Variables2
    for rule in rules:
        left = rule[0]  # considering CFG rules given in cfg.gr files
        leftPos = variables.index(left)

        right = rule[1]

        isRight(l, left, p, right, s, table, words)


def parser(terms, var, string, pR):
    N = wordsCount(string, terms)
    P = len(var)
    result = False

    # Initializing table
    table = [[[] for i in range(N)] for j in range(N)]

    # Constructing substrings that have the length of 1
    construct1L(N, pR, string, table, var)

    # Constructing substrings that have the length of greater than 1 and smaller than N
    constructSubs(N, pR, table, terms, var)

    lastLength = len(table[N - 1][0])
    lastVector = []

    a = table[N - 1][0]

    for i in range(lastLength):
        lastVector.append(getToken(table[N - 1][0][i].token))

    if var[0] in lastVector:
        result = True
        print('The sentence is given that \'' + string + '\' is grammatically correct according to given grammar rules.')
        print(' ')

    else:
        print('The sentence is given that \'' + string + '\' is not grammatically correct according to given grammar rules.')
        print(' ')


    return result


def construct1L(N, pR, string, table, var):
    if ' ' in string:
        splits = string.split(' ')
        for s in range(1, N + 1):
            updateFirstWord(splits[s - 1], s - 1, pR, var, table)
    else:
        for s in range(1, N + 1):
            updateFirstWord(string[s - 1], s - 1, pR, var, table)


def constructSubs(N, pR, table, terms, var):
    for l in range(2, N + 1):  # l indicates the length of the substring
        for s in range(1,
                       N - l + 2):  # s indicates the number of substrings that have length l in the tested string
            for p in range(1,
                           l):  # p indicates different combination of sub-spans and helps to split the span generated by l
                updateWords(pR, var, terms, table, l - 1, s - 1, p - 1)


def nameCheck():
    global abbreviation, words, rules, checked_sentence
    if __name__ == '__main__':
        abbreviation = ["S", "NP", "VP", "Verb", "Noun", "PP", "Det", "Prep", "Adj"]
        words = ["ate", "wanted", "kissed", "washed", "pickled", "the", "a", "every", "president", "sandwich", "pickle",
                 "mouse", "floor",
                 "fine", "delicious", "beautiful", "old", "with", "on", "under", "in"]

        rules = [("S", "NP VP"), ("VP", "Verb NP"), ("NP", "Det Noun"), ("NP", "NP PP"), ("PP", "Prep NP"),
                 ("Noun", "Adj Noun"), ("Verb", "ate"), ("Verb", "wanted"),
                 ("Verb", "kissed"), ("Verb", "washed"), ("Verb", "pickled"), ("Det", "the"), ("Det", "a"),
                 ("Det", "every"), ("Noun", "president"), ("Noun", "sandwich"),
                 ("Noun", "pickle"), ("Noun", "mouse"), ("Noun", "floor"), ("Adj", "fine"), ("Adj", "delicious"),
                 ("Adj", "beautiful"), ("Adj", "old"), ("Prep", "with"),
                 ("Prep", "on"), ("Prep", "under"), ("Prep", "in")]

        f = open("sentence.txt", "r")
        f1 = f.readline()
        checked_sentence = f1



nameCheck()


checked_output = parser(words, abbreviation, checked_sentence, rules)
